From b568f1120349bbe570439567c030aa7ad0e916d0 Mon Sep 17 00:00:00 2001

From: Moritz 'Morty' Str√ºbe <morty@gmx.net>

Subject: Change indention of AbstractRadioMedium to tabs
---
 .../cooja/radiomediums/AbstractRadioMedium.java    |  824 ++++++++++----------
 1 files changed, 412 insertions(+), 412 deletions(-)

diff --git a/tools/cooja/java/se/sics/cooja/radiomediums/AbstractRadioMedium.java b/tools/cooja/java/se/sics/cooja/radiomediums/AbstractRadioMedium.java
index b0b4d1e..3ae9b52 100644
--- a/tools/cooja/java/se/sics/cooja/radiomediums/AbstractRadioMedium.java
+++ b/tools/cooja/java/se/sics/cooja/radiomediums/AbstractRadioMedium.java
@@ -62,416 +62,416 @@ import se.sics.cooja.interfaces.Radio;
  * @author Fredrik Osterlind
  */
 public abstract class AbstractRadioMedium extends RadioMedium {
-  private static Logger logger = Logger.getLogger(AbstractRadioMedium.class);
-
-  /* Signal strengths in dBm.
-   * Approx. values measured on TmoteSky */
-  public static final double SS_NOTHING = -100;
-  public static final double SS_STRONG = -10;
-  public static final double SS_WEAK = -95;
-
-  private ArrayList<Radio> registeredRadios = new ArrayList<Radio>();
-
-  private ArrayList<RadioConnection> activeConnections = new ArrayList<RadioConnection>();
-
-  private RadioConnection lastConnection = null;
-
-  private Simulation simulation = null;
-
-  /* Book-keeping */
-  public int COUNTER_TX = 0;
-  public int COUNTER_RX = 0;
-  public int COUNTER_INTERFERED = 0;
-
-  public class RadioMediumObservable extends Observable {
-    public void setRadioMediumChanged() {
-      setChanged();
-    }
-    public void setRadioMediumChangedAndNotify() {
-      setChanged();
-      notifyObservers();
-    }
-  }
-
-  private RadioMediumObservable radioMediumObservable = new RadioMediumObservable();
-
-  /**
-   * This constructor should always be called from implemented radio mediums.
-   *
-   * @param simulation Simulation
-   */
-  public AbstractRadioMedium(Simulation simulation) {
-    this.simulation = simulation;
-  }
-
-  /**
-   * @return All registered radios
-   */
-  public Radio[] getRegisteredRadios() {
-    return registeredRadios.toArray(new Radio[0]);
-  }
-
-  /**
-   * @return All active connections
-   */
-  public RadioConnection[] getActiveConnections() {
-    /* NOTE: toArray([0]) creates array and handles synchronization */
-    return activeConnections.toArray(new RadioConnection[0]);
-  }
-
-  /**
-   * Creates a new connection from given radio.
-   *
-   * Determines which radios should receive or be interfered by the transmission.
-   *
-   * @param radio Source radio
-   * @return New connection
-   */
-  abstract public RadioConnection createConnections(Radio radio);
-
-  /**
-   * Updates all radio interfaces' signal strengths according to
-   * the current active connections.
-   */
-  public void updateSignalStrengths() {
-
-    /* Reset signal strengths */
-    for (Radio radio : getRegisteredRadios()) {
-      radio.setCurrentSignalStrength(SS_NOTHING);
-    }
-
-    /* Set signal strength to strong on destinations */
-    RadioConnection[] conns = getActiveConnections();
-    for (RadioConnection conn : conns) {
-      if (conn.getSource().getCurrentSignalStrength() < SS_STRONG) {
-        conn.getSource().setCurrentSignalStrength(SS_STRONG);
-      }
-      for (Radio dstRadio : conn.getDestinations()) {
-        if (conn.getSource().getChannel() >= 0 &&
-            dstRadio.getChannel() >= 0 &&
-            conn.getSource().getChannel() != dstRadio.getChannel()) {
-          continue;
-        }
-        if (dstRadio.getCurrentSignalStrength() < SS_STRONG) {
-          dstRadio.setCurrentSignalStrength(SS_STRONG);
-        }
-      }
-    }
-
-    /* Set signal strength to weak on interfered */
-    for (RadioConnection conn : conns) {
-      for (Radio intfRadio : conn.getInterfered()) {
-        if (intfRadio.getCurrentSignalStrength() < SS_STRONG) {
-          intfRadio.setCurrentSignalStrength(SS_STRONG);
-        }
-        if (conn.getSource().getChannel() >= 0 &&
-            intfRadio.getChannel() >= 0 &&
-            conn.getSource().getChannel() != intfRadio.getChannel()) {
-          continue;
-        }
-        if (!intfRadio.isInterfered()) {
-          /*logger.warn("Radio was not interfered");*/
-          intfRadio.interfereAnyReception();
-        }
-      }
-    }
-  }
-
-
-  /**
-   * Remove given radio from any active connections.
-   * This method can be called if a radio node falls asleep or is removed.
-   *
-   * @param radio Radio
-   */
-  private void removeFromActiveConnections(Radio radio) {
-    /* This radio must not be a connection source */
-    RadioConnection connection = getActiveConnectionFrom(radio);
-    if (connection != null) {
-      logger.fatal("Connection source turned off radio: " + radio);
-    }
-
-    /* Set interfered if currently a connection destination */
-    for (RadioConnection conn : activeConnections) {
-      if (conn.isDestination(radio)) {
-        conn.addInterfered(radio);
-        if (!radio.isInterfered()) {
-          radio.interfereAnyReception();
-        }
-      }
-    }
-  }
-
-  private RadioConnection getActiveConnectionFrom(Radio source) {
-    for (RadioConnection conn : activeConnections) {
-      if (conn.getSource() == source) {
-        return conn;
-      }
-    }
-    return null;
-  }
-
-  /**
-   * This observer is responsible for detecting radio interface events, for example
-   * new transmissions.
-   */
-  private Observer radioEventsObserver = new Observer() {
-    public void update(Observable obs, Object obj) {
-      if (!(obs instanceof Radio)) {
-        logger.fatal("Radio event dispatched by non-radio object");
-        return;
-      }
-      Radio radio = (Radio) obs;
-
-      final Radio.RadioEvent event = radio.getLastEvent();
-      if (event == Radio.RadioEvent.RECEPTION_STARTED ||
-          event == Radio.RadioEvent.RECEPTION_INTERFERED ||
-          event == Radio.RadioEvent.RECEPTION_FINISHED ||
-          event == Radio.RadioEvent.UNKNOWN) {
-        /* Ignored */
-        return;
-      }
-
-      if (event == Radio.RadioEvent.HW_ON) {
-
-        /* Update signal strengths */
-        updateSignalStrengths();
-
-      } else if (event == Radio.RadioEvent.HW_OFF) {
-
-        /* Remove any radio connections from this radio */
-        removeFromActiveConnections(radio);
-
-        /* Update signal strengths */
-        updateSignalStrengths();
-
-      } else if (event == Radio.RadioEvent.TRANSMISSION_STARTED) {
-        /* Create new radio connection */
-
-        if (radio.isReceiving()) {
-          /* Radio starts transmitting when it should be receiving!
-           * Ok, but it won't receive the packet */
-          for (RadioConnection conn : activeConnections) {
-            if (conn.isDestination(radio)) {
-              conn.addInterfered(radio);
-            }
-          }
-          radio.interfereAnyReception();
-        }
-        
-        RadioConnection newConnection = createConnections(radio);
-        activeConnections.add(newConnection);
-        for (Radio r: newConnection.getAllDestinations()) {
-          if (newConnection.getDestinationDelay(r) == 0) {
-            r.signalReceptionStart();
-          } else {
-
-            /* EXPERIMENTAL: Simulating propagation delay */
-            final Radio delayedRadio = r;
-            TimeEvent delayedEvent = new TimeEvent(0) {
-              public void execute(long t) {
-                delayedRadio.signalReceptionStart();
-              }
-            };
-            simulation.scheduleEvent(
-                delayedEvent,
-                simulation.getSimulationTime() + newConnection.getDestinationDelay(r));
-
-          }
-        }
-
-        /* Update signal strengths */
-        updateSignalStrengths();
-
-        /* Notify observers */
-        lastConnection = null;
-        radioMediumObservable.setRadioMediumChangedAndNotify();
-
-      } else if (event == Radio.RadioEvent.TRANSMISSION_FINISHED) {
-        /* Remove radio connection */
-
-        /* Connection */
-        RadioConnection connection = getActiveConnectionFrom(radio);
-        if (connection == null) {
-          logger.fatal("No radio connection found");
-          return;
-        }
-
-        activeConnections.remove(connection);
-        lastConnection = connection;
-        COUNTER_TX++;
-        for (Radio dstRadio : connection.getAllDestinations()) {
-          if (connection.getDestinationDelay(dstRadio) == 0) {
-            dstRadio.signalReceptionEnd();
-          } else {
-
-            /* EXPERIMENTAL: Simulating propagation delay */
-            final Radio delayedRadio = dstRadio;
-            TimeEvent delayedEvent = new TimeEvent(0) {
-              public void execute(long t) {
-                delayedRadio.signalReceptionEnd();
-              }
-            };
-            simulation.scheduleEvent(
-                delayedEvent,
-                simulation.getSimulationTime() + connection.getDestinationDelay(dstRadio));
-          }
-        }
-        COUNTER_RX += connection.getDestinations().length;
-        COUNTER_INTERFERED += connection.getInterfered().length;
-        for (Radio intRadio : connection.getInterferedNonDestinations()) {
-          intRadio.signalReceptionEnd();
-        }
-
-        /* Update signal strengths */
-        updateSignalStrengths();
-
-        /* Notify observers */
-        radioMediumObservable.setRadioMediumChangedAndNotify();
-
-      } else if (event == Radio.RadioEvent.CUSTOM_DATA_TRANSMITTED) {
-
-        /* Connection */
-        RadioConnection connection = getActiveConnectionFrom(radio);
-        if (connection == null) {
-          logger.fatal("No radio connection found");
-          return;
-        }
-
-        /* Custom data object */
-        Object data = ((CustomDataRadio) radio).getLastCustomDataTransmitted();
-        if (data == null) {
-          logger.fatal("No custom data object to forward");
-          return;
-        }
-
-        for (Radio dstRadio : connection.getAllDestinations()) {
-
-          if (!radio.getClass().equals(dstRadio.getClass()) ||
-              !(radio instanceof CustomDataRadio)) {
-            /* Radios communicate via radio packets */
-            continue;
-          }
-
-          if (connection.getDestinationDelay(dstRadio) == 0) {
-            ((CustomDataRadio) dstRadio).receiveCustomData(data);
-          } else {
-
-            /* EXPERIMENTAL: Simulating propagation delay */
-            final CustomDataRadio delayedRadio = (CustomDataRadio) dstRadio;
-            final Object delayedData = data;
-            TimeEvent delayedEvent = new TimeEvent(0) {
-              public void execute(long t) {
-                delayedRadio.receiveCustomData(delayedData);
-              }
-            };
-            simulation.scheduleEvent(
-                delayedEvent,
-                simulation.getSimulationTime() + connection.getDestinationDelay(dstRadio));
-
-          }
-        }
-
-      } else if (event == Radio.RadioEvent.PACKET_TRANSMITTED) {
-
-        /* Connection */
-        RadioConnection connection = getActiveConnectionFrom(radio);
-        if (connection == null) {
-          logger.fatal("No radio connection found");
-          return;
-        }
-
-        /* Radio packet */
-        RadioPacket packet = radio.getLastPacketTransmitted();
-        if (packet == null) {
-          logger.fatal("No radio packet to forward");
-          return;
-        }
-
-        for (Radio dstRadio : connection.getAllDestinations()) {
-
-          if (radio.getClass().equals(dstRadio.getClass()) &&
-              radio instanceof CustomDataRadio) {
-            /* Radios instead communicate via custom data objects */
-            continue;
-          }
-
-          /* Forward radio packet */
-          if (connection.getDestinationDelay(dstRadio) == 0) {
-            dstRadio.setReceivedPacket(packet);
-          } else {
-
-            /* EXPERIMENTAL: Simulating propagation delay */
-            final Radio delayedRadio = dstRadio;
-            final RadioPacket delayedPacket = packet;
-            TimeEvent delayedEvent = new TimeEvent(0) {
-              public void execute(long t) {
-                delayedRadio.setReceivedPacket(delayedPacket);
-              }
-            };
-            simulation.scheduleEvent(
-                delayedEvent,
-                simulation.getSimulationTime() + connection.getDestinationDelay(dstRadio));
-          }
-
-        }
-
-      } else {
-        logger.fatal("Unsupported radio event: " + event);
-      }
-    }
-  };
-
-  public void registerMote(Mote mote, Simulation sim) {
-    registerRadioInterface(mote.getInterfaces().getRadio(), sim);
-  }
-
-  public void unregisterMote(Mote mote, Simulation sim) {
-    unregisterRadioInterface(mote.getInterfaces().getRadio(), sim);
-  }
-
-  public void registerRadioInterface(Radio radio, Simulation sim) {
-    if (radio == null) {
-      logger.warn("No radio to register");
-      return;
-    }
-
-    registeredRadios.add(radio);
-    radio.addObserver(radioEventsObserver);
-
-    /* Update signal strengths */
-    updateSignalStrengths();
-  }
-
-  public void unregisterRadioInterface(Radio radio, Simulation sim) {
-    if (!registeredRadios.contains(radio)) {
-      logger.warn("No radio to unregister: " + radio);
-      return;
-    }
-
-    radio.deleteObserver(radioEventsObserver);
-    registeredRadios.remove(radio);
-
-    removeFromActiveConnections(radio);
-
-    /* Update signal strengths */
-    updateSignalStrengths();
-  }
-
-  public void addRadioMediumObserver(Observer observer) {
-    radioMediumObservable.addObserver(observer);
-  }
-
-  public Observable getRadioMediumObservable() {
-    return radioMediumObservable;
-  }
-
-  public void deleteRadioMediumObserver(Observer observer) {
-    radioMediumObservable.deleteObserver(observer);
-  }
-
-  public RadioConnection getLastConnection() {
-    return lastConnection;
-  }
-
+	private static Logger logger = Logger.getLogger(AbstractRadioMedium.class);
+	
+	/* Signal strengths in dBm.
+	 * Approx. values measured on TmoteSky */
+	public static final double SS_NOTHING = -100;
+	public static final double SS_STRONG = -10;
+	public static final double SS_WEAK = -95;
+	
+	private ArrayList<Radio> registeredRadios = new ArrayList<Radio>();
+	
+	private ArrayList<RadioConnection> activeConnections = new ArrayList<RadioConnection>();
+	
+	private RadioConnection lastConnection = null;
+	
+	private Simulation simulation = null;
+	
+	/* Book-keeping */
+	public int COUNTER_TX = 0;
+	public int COUNTER_RX = 0;
+	public int COUNTER_INTERFERED = 0;
+	
+	public class RadioMediumObservable extends Observable {
+		public void setRadioMediumChanged() {
+			setChanged();
+		}
+		public void setRadioMediumChangedAndNotify() {
+			setChanged();
+			notifyObservers();
+		}
+	}
+	
+	private RadioMediumObservable radioMediumObservable = new RadioMediumObservable();
+	
+	/**
+	 * This constructor should always be called from implemented radio mediums.
+	 *
+	 * @param simulation Simulation
+	 */
+	public AbstractRadioMedium(Simulation simulation) {
+		this.simulation = simulation;
+	}
+	
+	/**
+	 * @return All registered radios
+	 */
+	public Radio[] getRegisteredRadios() {
+		return registeredRadios.toArray(new Radio[0]);
+	}
+	
+	/**
+	 * @return All active connections
+	 */
+	public RadioConnection[] getActiveConnections() {
+		/* NOTE: toArray([0]) creates array and handles synchronization */
+		return activeConnections.toArray(new RadioConnection[0]);
+	}
+	
+	/**
+	 * Creates a new connection from given radio.
+	 *
+	 * Determines which radios should receive or be interfered by the transmission.
+	 *
+	 * @param radio Source radio
+	 * @return New connection
+	 */
+	abstract public RadioConnection createConnections(Radio radio);
+	
+	/**
+	 * Updates all radio interfaces' signal strengths according to
+	 * the current active connections.
+	 */
+	public void updateSignalStrengths() {
+		
+		/* Reset signal strengths */
+		for (Radio radio : getRegisteredRadios()) {
+			radio.setCurrentSignalStrength(SS_NOTHING);
+		}
+		
+		/* Set signal strength to strong on destinations */
+		RadioConnection[] conns = getActiveConnections();
+		for (RadioConnection conn : conns) {
+			if (conn.getSource().getCurrentSignalStrength() < SS_STRONG) {
+				conn.getSource().setCurrentSignalStrength(SS_STRONG);
+			}
+			for (Radio dstRadio : conn.getDestinations()) {
+				if (conn.getSource().getChannel() >= 0 &&
+						dstRadio.getChannel() >= 0 &&
+						conn.getSource().getChannel() != dstRadio.getChannel()) {
+					continue;
+				}
+				if (dstRadio.getCurrentSignalStrength() < SS_STRONG) {
+					dstRadio.setCurrentSignalStrength(SS_STRONG);
+				}
+			}
+		}
+		
+		/* Set signal strength to weak on interfered */
+		for (RadioConnection conn : conns) {
+			for (Radio intfRadio : conn.getInterfered()) {
+				if (intfRadio.getCurrentSignalStrength() < SS_STRONG) {
+					intfRadio.setCurrentSignalStrength(SS_STRONG);
+				}
+				if (conn.getSource().getChannel() >= 0 &&
+						intfRadio.getChannel() >= 0 &&
+						conn.getSource().getChannel() != intfRadio.getChannel()) {
+					continue;
+				}
+				if (!intfRadio.isInterfered()) {
+					/*logger.warn("Radio was not interfered");*/
+					intfRadio.interfereAnyReception();
+				}
+			}
+		}
+	}
+	
+	
+	/**
+	 * Remove given radio from any active connections.
+	 * This method can be called if a radio node falls asleep or is removed.
+	 *
+	 * @param radio Radio
+	 */
+	private void removeFromActiveConnections(Radio radio) {
+		/* This radio must not be a connection source */
+		RadioConnection connection = getActiveConnectionFrom(radio);
+		if (connection != null) {
+			logger.fatal("Connection source turned off radio: " + radio);
+		}
+		
+		/* Set interfered if currently a connection destination */
+		for (RadioConnection conn : activeConnections) {
+			if (conn.isDestination(radio)) {
+				conn.addInterfered(radio);
+				if (!radio.isInterfered()) {
+					radio.interfereAnyReception();
+				}
+			}
+		}
+	}
+	
+	private RadioConnection getActiveConnectionFrom(Radio source) {
+		for (RadioConnection conn : activeConnections) {
+			if (conn.getSource() == source) {
+				return conn;
+			}
+		}
+		return null;
+	}
+	
+	/**
+	 * This observer is responsible for detecting radio interface events, for example
+	 * new transmissions.
+	 */
+	private Observer radioEventsObserver = new Observer() {
+		public void update(Observable obs, Object obj) {
+			if (!(obs instanceof Radio)) {
+				logger.fatal("Radio event dispatched by non-radio object");
+				return;
+			}
+			Radio radio = (Radio) obs;
+			
+			final Radio.RadioEvent event = radio.getLastEvent();
+			if (event == Radio.RadioEvent.RECEPTION_STARTED ||
+					event == Radio.RadioEvent.RECEPTION_INTERFERED ||
+					event == Radio.RadioEvent.RECEPTION_FINISHED ||
+					event == Radio.RadioEvent.UNKNOWN) {
+				/* Ignored */
+				return;
+			}
+			
+			if (event == Radio.RadioEvent.HW_ON) {
+				
+				/* Update signal strengths */
+				updateSignalStrengths();
+				
+			} else if (event == Radio.RadioEvent.HW_OFF) {
+				
+				/* Remove any radio connections from this radio */
+				removeFromActiveConnections(radio);
+				
+				/* Update signal strengths */
+				updateSignalStrengths();
+				
+			} else if (event == Radio.RadioEvent.TRANSMISSION_STARTED) {
+				/* Create new radio connection */
+				
+				if (radio.isReceiving()) {
+					/* Radio starts transmitting when it should be receiving!
+					 * Ok, but it won't receive the packet */
+					for (RadioConnection conn : activeConnections) {
+						if (conn.isDestination(radio)) {
+							conn.addInterfered(radio);
+						}
+					}
+					radio.interfereAnyReception();
+				}
+				
+				RadioConnection newConnection = createConnections(radio);
+				activeConnections.add(newConnection);
+				for (Radio r: newConnection.getAllDestinations()) {
+					if (newConnection.getDestinationDelay(r) == 0) {
+						r.signalReceptionStart();
+					} else {
+						
+						/* EXPERIMENTAL: Simulating propagation delay */
+						final Radio delayedRadio = r;
+						TimeEvent delayedEvent = new TimeEvent(0) {
+							public void execute(long t) {
+								delayedRadio.signalReceptionStart();
+							}
+						};
+						simulation.scheduleEvent(
+								delayedEvent,
+								simulation.getSimulationTime() + newConnection.getDestinationDelay(r));
+						
+					}
+				}
+				
+				/* Update signal strengths */
+				updateSignalStrengths();
+				
+				/* Notify observers */
+				lastConnection = null;
+				radioMediumObservable.setRadioMediumChangedAndNotify();
+				
+			} else if (event == Radio.RadioEvent.TRANSMISSION_FINISHED) {
+				/* Remove radio connection */
+				
+				/* Connection */
+				RadioConnection connection = getActiveConnectionFrom(radio);
+				if (connection == null) {
+					logger.fatal("No radio connection found");
+					return;
+				}
+				
+				activeConnections.remove(connection);
+				lastConnection = connection;
+				COUNTER_TX++;
+				for (Radio dstRadio : connection.getAllDestinations()) {
+					if (connection.getDestinationDelay(dstRadio) == 0) {
+						dstRadio.signalReceptionEnd();
+					} else {
+						
+						/* EXPERIMENTAL: Simulating propagation delay */
+						final Radio delayedRadio = dstRadio;
+						TimeEvent delayedEvent = new TimeEvent(0) {
+							public void execute(long t) {
+								delayedRadio.signalReceptionEnd();
+							}
+						};
+						simulation.scheduleEvent(
+								delayedEvent,
+								simulation.getSimulationTime() + connection.getDestinationDelay(dstRadio));
+					}
+				}
+				COUNTER_RX += connection.getDestinations().length;
+				COUNTER_INTERFERED += connection.getInterfered().length;
+				for (Radio intRadio : connection.getInterferedNonDestinations()) {
+					intRadio.signalReceptionEnd();
+				}
+				
+				/* Update signal strengths */
+				updateSignalStrengths();
+				
+				/* Notify observers */
+				radioMediumObservable.setRadioMediumChangedAndNotify();
+				
+			} else if (event == Radio.RadioEvent.CUSTOM_DATA_TRANSMITTED) {
+				
+				/* Connection */
+				RadioConnection connection = getActiveConnectionFrom(radio);
+				if (connection == null) {
+					logger.fatal("No radio connection found");
+					return;
+				}
+				
+				/* Custom data object */
+				Object data = ((CustomDataRadio) radio).getLastCustomDataTransmitted();
+				if (data == null) {
+					logger.fatal("No custom data object to forward");
+					return;
+				}
+				
+				for (Radio dstRadio : connection.getAllDestinations()) {
+					
+					if (!radio.getClass().equals(dstRadio.getClass()) ||
+							!(radio instanceof CustomDataRadio)) {
+						/* Radios communicate via radio packets */
+						continue;
+					}
+					
+					if (connection.getDestinationDelay(dstRadio) == 0) {
+						((CustomDataRadio) dstRadio).receiveCustomData(data);
+					} else {
+						
+						/* EXPERIMENTAL: Simulating propagation delay */
+						final CustomDataRadio delayedRadio = (CustomDataRadio) dstRadio;
+						final Object delayedData = data;
+						TimeEvent delayedEvent = new TimeEvent(0) {
+							public void execute(long t) {
+								delayedRadio.receiveCustomData(delayedData);
+							}
+						};
+						simulation.scheduleEvent(
+								delayedEvent,
+								simulation.getSimulationTime() + connection.getDestinationDelay(dstRadio));
+						
+					}
+				}
+				
+			} else if (event == Radio.RadioEvent.PACKET_TRANSMITTED) {
+				
+				/* Connection */
+				RadioConnection connection = getActiveConnectionFrom(radio);
+				if (connection == null) {
+					logger.fatal("No radio connection found");
+					return;
+				}
+				
+				/* Radio packet */
+				RadioPacket packet = radio.getLastPacketTransmitted();
+				if (packet == null) {
+					logger.fatal("No radio packet to forward");
+					return;
+				}
+				
+				for (Radio dstRadio : connection.getAllDestinations()) {
+					
+					if (radio.getClass().equals(dstRadio.getClass()) &&
+							radio instanceof CustomDataRadio) {
+						/* Radios instead communicate via custom data objects */
+						continue;
+					}
+					
+					/* Forward radio packet */
+					if (connection.getDestinationDelay(dstRadio) == 0) {
+						dstRadio.setReceivedPacket(packet);
+					} else {
+						
+						/* EXPERIMENTAL: Simulating propagation delay */
+						final Radio delayedRadio = dstRadio;
+						final RadioPacket delayedPacket = packet;
+						TimeEvent delayedEvent = new TimeEvent(0) {
+							public void execute(long t) {
+								delayedRadio.setReceivedPacket(delayedPacket);
+							}
+						};
+						simulation.scheduleEvent(
+								delayedEvent,
+								simulation.getSimulationTime() + connection.getDestinationDelay(dstRadio));
+					}
+					
+				}
+				
+			} else {
+				logger.fatal("Unsupported radio event: " + event);
+			}
+		}
+	};
+	
+	public void registerMote(Mote mote, Simulation sim) {
+		registerRadioInterface(mote.getInterfaces().getRadio(), sim);
+	}
+	
+	public void unregisterMote(Mote mote, Simulation sim) {
+		unregisterRadioInterface(mote.getInterfaces().getRadio(), sim);
+	}
+	
+	public void registerRadioInterface(Radio radio, Simulation sim) {
+		if (radio == null) {
+			logger.warn("No radio to register");
+			return;
+		}
+		
+		registeredRadios.add(radio);
+		radio.addObserver(radioEventsObserver);
+		
+		/* Update signal strengths */
+		updateSignalStrengths();
+	}
+	
+	public void unregisterRadioInterface(Radio radio, Simulation sim) {
+		if (!registeredRadios.contains(radio)) {
+			logger.warn("No radio to unregister: " + radio);
+			return;
+		}
+		
+		radio.deleteObserver(radioEventsObserver);
+		registeredRadios.remove(radio);
+		
+		removeFromActiveConnections(radio);
+		
+		/* Update signal strengths */
+		updateSignalStrengths();
+	}
+	
+	public void addRadioMediumObserver(Observer observer) {
+		radioMediumObservable.addObserver(observer);
+	}
+	
+	public Observable getRadioMediumObservable() {
+		return radioMediumObservable;
+	}
+	
+	public void deleteRadioMediumObserver(Observer observer) {
+		radioMediumObservable.deleteObserver(observer);
+	}
+	
+	public RadioConnection getLastConnection() {
+		return lastConnection;
+	}
+	
 }
